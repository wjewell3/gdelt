<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GDELT News Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      padding: 0;
    }
    .chart-container {
      margin-bottom: 20px;
    }
    #docThumbnails {
      display: flex;
      flex-wrap: wrap;
    }
    #docThumbnails div {
      margin: 10px;
      text-align: center;
    }
    img {
      max-width: 250px;
      max-height: 250px;
      width: auto;
      height: auto;
    }
    .chart-container canvas {
      height: 300px;
    }
    .bar-chart-container {
      width: 100%;
    }
    .bar-chart-container canvas {
      height: 400px;
    }
  </style>
</head>
<body>
  <h1>GDELT News Dashboard</h1>
  <h3>Click any viz to filter dashboard</h3>
  <button id="resetButton" style="position: absolute; top: 10px; right: 10px; z-index: 1000;">Reset</button>

  <div class="chart-container">
    <h2>Articles</h2>
    <div id="docThumbnails"></div>
  </div>

  <div class="chart-container">
    <h2>Tone Counts</h2>
    <canvas id="toneHistogram"></canvas>
    <div id="avgOverallTone"></div>
  </div>

  <div class="chart-container">
    <h2>Theme Counts</h2>
    <canvas id="themeBarChart"></canvas>
  </div>

  <div class="chart-container">
    <h2>Person Counts</h2>
    <canvas id="personsBarChart"></canvas>
  </div>

  <div class="chart-container">
    <h2>Map Counts</h2>
    <div id="countryMap" style="height: 600px; width: 100%;"></div>
  </div>

  <div class="chart-container">
    <h2>Organization Counts</h2>
    <canvas id="orgsBarChart"></canvas>
  </div>

  <script>
    const sheets = {
      toneData: 'https://docs.google.com/spreadsheets/d/1Ct9OJZXJFgPXS0A1_TAstrHR4AIxyhegQDH0-gODP9k/edit?usp=drive_link/edit?gid=0#gid=0',
      themesData: 'https://docs.google.com/spreadsheets/d/12OWbeM-QywGaHxAs3xVSIkmdQOKLva2nFLxkLrMeaTg/edit?usp=drive_link/edit?gid=0#gid=0',
      documentData: 'https://docs.google.com/spreadsheets/d/1Ct9OJZXJFgPXS0A1_TAstrHR4AIxyhegQDH0-gODP9k/edit?usp=drive_link/edit?gid=0#gid=0',
      personsData: 'https://docs.google.com/spreadsheets/d/1btPN5QimxjvrYdy1DvcaoKtN2uwuSHkZFjlq6yoU5gU/edit?usp=drive_link/edit?gid=0#gid=0',
      countryData: 'https://docs.google.com/spreadsheets/d/13KdBTY_aS-T_1T6_bAhTHxKwur18yCaUDUypqZfgHc4/edit?usp=drive_link/edit?gid=0#gid=0',
      orgsData: 'https://docs.google.com/spreadsheets/d/1My2Q6pZ9xKyuJM_k1vrnXYX1ma9un4ecutUbEwfKrOI/edit?usp=drive_link/edit?gid=0#gid=0'
    };

    const dataUrl = 'https://us-central1-gdelt-433201.cloudfunctions.net/function-3';
    let pollingAttempts = 0;
    const maxPollingAttempts = 1;

    async function fetchData() {
      try {
        // Use 'no-cors' mode since you don't care about the response
        await fetch(dataUrl, { mode: 'no-cors' });
        console.log('Request made to:', dataUrl);
      } catch (error) {
        console.error('Failed to make request:', error);
      }
    }

    async function checkForUpdates() {
      await fetchData();

      if (pollingAttempts < maxPollingAttempts) {
        pollingAttempts++;
        setTimeout(checkForUpdates, 30000); // Poll every 30 seconds
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      checkForUpdates();
    });

    async function fetchSheetData(sheetUrl) {
      try {
        const sheetId = sheetUrl.split('/')[5];
        const sheetName = sheetUrl.split('gid=')[1];
        const url = `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:json&sheet=${sheetName}`;
        const response = await fetch(url);
        const text = await response.text();
        const match = text.match(/\{.*\}/s);
        if (match) {
          return JSON.parse(match[0]);
        }
        throw new Error('Failed to parse JSON data');
      } catch (error) {
        console.error('Failed to fetch or parse data:', error);
        return null;
      }
    }

    function processToneData(data) {
      // console.log("Tone Data:", data); // Debugging line
      // console.log(data)
      if (!data) return { toneBins: [], avgTone: 0, labels: [] };
      const rows = data.table.rows.slice(1); // Skip the header row
      const toneValues = rows.map(row => parseFloat(row.c[7].v)); // Adjust index if needed
      const avgTone = toneValues.reduce((a, b) => a + b, 0) / toneValues.length;

      // Binning the tone values into 10 bins
      const minTone = Math.min(...toneValues);
      const maxTone = Math.max(...toneValues);
      const binSize = (maxTone - minTone) / 10;
      const toneBins = Array(10).fill(0);
// come back and fill this in to get associated gkg ids like we did for themes
      // rows.forEach(row => {
      //   const tone = row.c[7].v;
      //   const count = 0;
      //   const gkgID = row.c[0].v;
      //   if (themes[theme]) {
      //     themes[theme].count += 1;
      //     themes[theme].gkgIDs.push(gkgID);
      //   } else {
      //     themes[theme] = { count, gkgIDs: [gkgID] };
      //   }
      // });

      toneValues.forEach(value => {
        const binIndex = Math.min(Math.floor((value - minTone) / binSize), 9);
        toneBins[binIndex] += 1;
      });

      // Create labels for tone ranges
      const labels = Array.from({ length: 10 }, (_, i) => {
        const rangeStart = (minTone + i * binSize).toFixed(2);
        const rangeEnd = (minTone + (i + 1) * binSize).toFixed(2);
        return `${rangeStart} - ${rangeEnd}`;
      });

      return { toneBins, avgTone, labels };
    }

    function processThemesData(data) {
      if (!data) return { labels: [], counts: [], themes: {} };
      const rows = data.table.rows.slice(1); // Skip the header row
      const themes = {};
      rows.forEach(row => {
        const theme = row.c[1].v;
        const count = 0;
        const gkgID = row.c[0].v;
        if (themes[theme]) {
          themes[theme].count += 1;
          themes[theme].gkgIDs.push(gkgID);
        } else {
          themes[theme] = { count, gkgIDs: [gkgID] };
        }
      });
      const labels = Object.keys(themes).sort((a, b) => themes[b].count - themes[a].count).slice(0, 10);
      const counts = labels.map(label => themes[label].count);
      // console.log(themes)
      return { labels, counts, themes };
    }

    function processPersonsData(data) {
      if (!data) return { labels: [], counts: [], persons: {} };
      const rows = data.table.rows.slice(1); // Skip the header row
      const persons = {};
      rows.forEach(row => {
        const person = row.c[1].v;
        const count = 0;
        const gkgID = row.c[0].v;
        if (persons[person]) {
          persons[person].count += 1;
          persons[person].gkgIDs.push(gkgID);
        } else {
          persons[person] = { count, gkgIDs: [gkgID] };
        }
      });
      const labels = Object.keys(persons).sort((a, b) => persons[b].count - persons[a].count).slice(0, 10);
      const counts = labels.map(label => persons[label].count);
      return { labels, counts, persons };
    }

    function processOrgsData(data) {
      if (!data) return { labels: [], counts: [], orgs: {} };
      const rows = data.table.rows.slice(1); // Skip the header row
      const orgs = {};
      rows.forEach(row => {
        const org = row.c[1].v;
        const count = 0;
        const gkgID = row.c[0].v;
        if (orgs[org]) {
          orgs[org].count += 1;
          orgs[org].gkgIDs.push(gkgID);
        } else {
          orgs[org] = { count, gkgIDs: [gkgID] };
        }
      });
      const labels = Object.keys(orgs).sort((a, b) => orgs[b].count - orgs[a].count).slice(0, 10);
      const counts = labels.map(label => orgs[label].count);
      return { labels, counts, orgs };
    }

    function processDocsData(data) {
      if (!data) return [];
      const rows = data.table.rows.slice(1); // Skip the header row
      return rows.map(row => ({
        id: row.c[4].v,
        image: row.c[5].v,
        gkgID: row.c[0].v
      })).sort((a, b) => b.id.localeCompare(a.id)).slice(0, 10);
    }

    function processLocationsData(data) {
      if (!data || !data.table || !data.table.rows) return [];

      const rows = data.table.rows.slice(1); // Skip the header row
      const latlongMap = {};

      rows.forEach(row => {
        const lat = parseFloat(row.c[7]?.v);
        const lng = parseFloat(row.c[8]?.v);
        const gkgID = row.c[0]?.v;

        if (!isNaN(lat) && !isNaN(lng) && gkgID) {
          const key = `${lat},${lng}`; // Unique key for lat/lng combination

          if (!latlongMap[key]) {
            latlongMap[key] = { count: 0, gkgIDs: new Set() };
          }

          latlongMap[key].gkgIDs.add(gkgID); // Use a Set to store unique gkgIDs
          latlongMap[key].count = latlongMap[key].gkgIDs.size; // Count of unique gkgIDs
        }
      });

      // Convert latlongMap to an array of objects
      return Object.keys(latlongMap).map(key => {
        const [lat, lng] = key.split(',').map(Number);
        return {
          lat,
          lng,
          count: latlongMap[key].count,
          gkgIDs: Array.from(latlongMap[key].gkgIDs)
        };
      });
    }


    let globalGkgIds = []; // Global variable to store selected GKG IDs
    let toneChart, themeChart, personsChart, orgsChart, mappy; // Declare variables to store chart instances


    function filterDataByGkgIds(gkgIds, toneData, themesData, documentsData, personsData, locationsData, orgsData) {
      // Helper function to filter rows based on GKG IDs
      function filterRowsByGkgIds(data) {
        if (!data || !data.table || !data.table.rows) return data;
        return {
          ...data,
          table: {
            ...data.table,
            rows: data.table.rows.filter(row => gkgIds.includes(row.c[0].v))
          }
        };
      }

      // Process each dataset using the helper function
      const filteredData = {
        tone: processToneData(filterRowsByGkgIds(toneData)),
        themes: processThemesData(filterRowsByGkgIds(themesData)),
        documents: processDocsData(filterRowsByGkgIds(documentsData)),
        persons: processPersonsData(filterRowsByGkgIds(personsData)),
        locations: processLocationsData(filterRowsByGkgIds(locationsData)),
        orgs: processOrgsData(filterRowsByGkgIds(orgsData))
      };
      // console.log(toneData.table)
      return filteredData;
    }

    function handleChartClick(event, elements, chartData, chartType, data, toneData, themesData, documentsData, personsData, locationsData, orgsData) {
      console.log('Event:', event);
      console.log('Elements:', elements);
      console.log('Chart Data:', chartData);
      console.log('data',data);

      // console.log('chartData which should match data.themes.themes:',chartData);
      if (elements.length > 0) {
        const index = elements[0].index;
        const Label = event.chart.data.labels[index];

        if (chartData[Label]) {
          // console.log('Clicked on:',Label);
          // console.log(`chartData[Label] : ${chartData[Label]}`);

          const selectedGkgIds = chartData[Label].gkgIDs;
          globalGkgIds = selectedGkgIds;
          // console.log(globalGkgIds);

          const filteredData = filterDataByGkgIds(globalGkgIds, toneData, themesData, documentsData, personsData, locationsData, orgsData);
          // console.log('filteredData:',filteredData);
          renderCharts(filteredData, toneData, themesData, documentsData, personsData, locationsData, orgsData);
        } else {
          console.error(`No data found for label: ${Label}`);
        }
      }
    }

    function renderCharts(data, toneData, themesData, documentsData, personsData, locationsData, orgsData) {
      if (toneChart) toneChart.destroy();
      if (themeChart) themeChart.destroy();
      if (personsChart) personsChart.destroy();
      if (orgsChart) orgsChart.destroy();
        // Check if the map already exists, and if so, remove it
      if (mappy) {
        mappy.remove();
        mappy = null;
      }
      const toneCtx = document.getElementById('toneHistogram').getContext('2d');
      // const toneData = processToneData(data.tone);
      if (data.tone.toneBins.length === 0) {
        document.getElementById('toneHistogram').style.display = 'none';
      } else {
        toneChart = new Chart(toneCtx, {
          type: 'bar',
          data: {
            labels: data.tone.labels,
            datasets: [{
              label: 'Tone Count',
              data: data.tone.toneBins,
              backgroundColor: 'rgba(75, 192, 192, 0.2)',
              borderColor: 'rgba(75, 192, 192, 1)',
              borderWidth: 1
            }]
          },
          options: {
            scales: {
              x: {
                title: {
                  display: true,
                  text: 'Tone Range'
                },
                ticks: {
                  callback: function(value, index) {
                    return data.tone.labels[index];
                  }
                }
              },
              y: {
                beginAtZero: true,
                title: {
                  display: true,
                  text: 'Count'
                }
              }
            },
            // onClick: (event, elements) => handleChartClick(event, elements, data.tone.toneBins, 'tone')

          }
        });
        document.getElementById('avgOverallTone').textContent = `Average Overall Tone: ${data.tone.avgTone.toFixed(2)}`;
      }

  const themeCtx = document.getElementById('themeBarChart').getContext('2d');
  // const themesData = processThemesData(data.themes);
  // console.log('data.themes.themes: ',data.themes.themes)
  themeChart = new Chart(themeCtx, {
    type: 'bar',
    data: {
      labels: data.themes.labels,
      datasets: [{
        label: 'Article Count',
        data: data.themes.counts,
        backgroundColor: 'rgba(153, 102, 255, 0.2)',
        borderColor: 'rgba(153, 102, 255, 1)',
        borderWidth: 1
      }]
    },
    options: {
      indexAxis: 'y',
      scales: {
        x: {
          beginAtZero: true
        }
      },
      onClick: (event, elements) => handleChartClick(event, elements, data.themes.themes, 'themes', data, toneData, themesData, documentsData, personsData, locationsData, orgsData)
    }
  });

  const personsCtx = document.getElementById('personsBarChart').getContext('2d');
  // const personsData = processPersonsData(data.persons);
  personsChart = new Chart(personsCtx, {
    type: 'bar',
    data: {
      labels: data.persons.labels,
      datasets: [{
        label: 'Article Count',
        data: data.persons.counts,
        backgroundColor: 'rgba(255, 159, 64, 0.2)',
        borderColor: 'rgba(255, 159, 64, 1)',
        borderWidth: 1
      }]
    },
    options: {
      indexAxis: 'y',
      scales: {
        x: {
          beginAtZero: true
        }
      },
      onClick: (event, elements) => handleChartClick(event, elements, data.persons.persons, 'persons', data, toneData, themesData, documentsData, personsData, locationsData, orgsData)
    }
  });

  const orgsCtx = document.getElementById('orgsBarChart').getContext('2d');
  // const orgsData = processOrgsData(data.orgs);
  orgsChart = new Chart(orgsCtx, {
    type: 'bar',
    data: {
      labels: data.orgs.labels,
      datasets: [{
        label: 'Article Count',
        data: data.orgs.counts,
        backgroundColor: 'rgba(255, 99, 132, 0.2)',
        borderColor: 'rgba(255, 99, 132, 1)',
        borderWidth: 1
      }]
    },
    options: {
      indexAxis: 'y',
      scales: {
        x: {
          beginAtZero: true
        }
      },
      onClick: (event, elements) => handleChartClick(event, elements, data.orgs.orgs, 'orgs', data, toneData, themesData, documentsData, personsData, locationsData, orgsData)
    }
  });

  const docThumbnailsDiv = document.getElementById('docThumbnails');
  docThumbnailsDiv.innerHTML = ''; // Clear previous thumbnails
  // const docsData = processDocsData(data.documents);
  const seenImages = new Set();

  data.documents.forEach(doc => {
    if (seenImages.has(doc.image)) {
      return;
    }

    seenImages.add(doc.image);

    const div = document.createElement('div');

    const img = document.createElement('img');
    img.src = doc.image;
    img.alt = 'Document Image';
    img.onerror = function() {
      div.remove();
    };

    const a = document.createElement('a');
    a.href = doc.id;
    a.target = '_blank';
    a.appendChild(img);

    div.appendChild(a);
    docThumbnailsDiv.appendChild(div);
  });

  // Initialize the map only if it's not already initialized
  if (!mappy) {
    mappy = L.map('countryMap').setView([20, 0], 2);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(mappy);
  }

  // const locationsData = processLocationsData(data.locations);
  data.locations.forEach(location => {
    L.circle([location.lat, location.lng], {
      color: 'blue',
      fillColor: '#30f',
      fillOpacity: 0.5,
      radius: location.count * 1000
    }).addTo(mappy);
  });
}

async function initialize() {
  // grab data from google sheets
  const [toneData, themesData, documentsData, personsData, locationsData, orgsData] = await Promise.all([
    fetchSheetData(sheets.toneData),
    fetchSheetData(sheets.themesData),
    fetchSheetData(sheets.documentData),
    fetchSheetData(sheets.personsData),
    fetchSheetData(sheets.countryData),
    fetchSheetData(sheets.orgsData)
  ]);
  console.log(toneData);
  console.log(themesData);
  console.log(documentsData);
  console.log(personsData);
  console.log(locationsData);
  console.log(orgsData);
// get only fields i need broken out into labels, counts, and the raw data piece
  data = {
    tone: processToneData(toneData),
    themes: processThemesData(themesData),
    documents: processDocsData(documentsData),
    persons: processPersonsData(personsData),
    locations: processLocationsData(locationsData),
    orgs: processOrgsData(orgsData)
  };
  // console.log('initial data',data)

  renderCharts(data, toneData, themesData, documentsData, personsData, locationsData ,orgsData);
}

initialize();

document.getElementById('resetButton').addEventListener('click', async function() {
  // Call the initialize function when the reset button is clicked
  await initialize();
});

  </script>
</body>
</html>