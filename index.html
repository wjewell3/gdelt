<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      padding: 0;
    }
    .chart-container {
      margin-bottom: 20px;
    }
    #docThumbnails {
      display: flex;
      flex-wrap: wrap;
    }
    #docThumbnails div {
      margin: 10px;
      text-align: center;
    }
    img {
      max-width: 250px;
      max-height: 250px;
      width: auto;
      height: auto;
    }
    .chart-container canvas {
      height: 300px;
    }
    .bar-chart-container {
      width: 100%;
    }
    .bar-chart-container canvas {
      height: 400px;
    }
  </style>
</head>
<body>
  <h1>Dashboard</h1>

  <div class="chart-container">
    <h2>Tone Histogram</h2>
    <canvas id="toneHistogram"></canvas>
    <div id="avgOverallTone"></div>
  </div>

  <div class="chart-container">
    <h2>Themes Average Record Count</h2>
    <canvas id="themeBarChart"></canvas>
  </div>

  <div class="chart-container">
    <h2>Articles</h2>
    <div id="docThumbnails"></div>
  </div>

  <div class="chart-container">
    <h2>Persons Average Record Count</h2>
    <canvas id="personsBarChart"></canvas>
  </div>

  <div class="chart-container">
    <h2>Country Map with Bubbles</h2>
    <div id="countryMap" style="height: 600px; width: 100%;"></div>
  </div>

  <div class="chart-container">
    <h2>Organizations Average Record Count</h2>
    <canvas id="orgsBarChart"></canvas>
  </div>

  <script>
    const sheets = {
      toneData: 'https://docs.google.com/spreadsheets/d/1Ct9OJZXJFgPXS0A1_TAstrHR4AIxyhegQDH0-gODP9k/edit?usp=drive_link/edit?gid=0#gid=0',
      themesData: 'https://docs.google.com/spreadsheets/d/12OWbeM-QywGaHxAs3xVSIkmdQOKLva2nFLxkLrMeaTg/edit?usp=drive_link/edit?gid=0#gid=0',
      documentData: 'https://docs.google.com/spreadsheets/d/1Ct9OJZXJFgPXS0A1_TAstrHR4AIxyhegQDH0-gODP9k/edit?usp=drive_link/edit?gid=0#gid=0',
      personsData: 'https://docs.google.com/spreadsheets/d/1btPN5QimxjvrYdy1DvcaoKtN2uwuSHkZFjlq6yoU5gU/edit?usp=drive_link/edit?gid=0#gid=0',
      countryData: 'https://docs.google.com/spreadsheets/d/13KdBTY_aS-T_1T6_bAhTHxKwur18yCaUDUypqZfgHc4/edit?usp=drive_link/edit?gid=0#gid=0',
      orgsData: 'https://docs.google.com/spreadsheets/d/1My2Q6pZ9xKyuJM_k1vrnXYX1ma9un4ecutUbEwfKrOI/edit?usp=drive_link/edit?gid=0#gid=0'
    };

    const dataUrl = 'https://us-central1-gdelt-433201.cloudfunctions.net/function-3';
    let pollingAttempts = 0;
    const maxPollingAttempts = 1;

    async function fetchData() {
      try {
        // Use 'no-cors' mode since you don't care about the response
        await fetch(dataUrl, { mode: 'no-cors' });
        console.log('Request made to:', dataUrl);
      } catch (error) {
        console.error('Failed to make request:', error);
      }
    }

    async function checkForUpdates() {
      await fetchData();

      if (pollingAttempts < maxPollingAttempts) {
        pollingAttempts++;
        setTimeout(checkForUpdates, 30000); // Poll every 30 seconds
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      checkForUpdates();
    });

    async function fetchSheetData(sheetUrl) {
      try {
        const sheetId = sheetUrl.split('/')[5];
        const sheetName = sheetUrl.split('gid=')[1];
        const url = `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:json&sheet=${sheetName}`;
        const response = await fetch(url);
        const text = await response.text();
        const match = text.match(/\{.*\}/s);
        if (match) {
          return JSON.parse(match[0]);
        }
        throw new Error('Failed to parse JSON data');
      } catch (error) {
        console.error('Failed to fetch or parse data:', error);
        return null;
      }
    }

    function processToneData(data) {
      if (!data) return { toneBins: [], avgTone: 0, labels: [] };
      const rows = data.table.rows.slice(1); // Skip the header row
      const toneValues = rows.map(row => parseFloat(row.c[7].v)); // Adjust index if needed
      const avgTone = toneValues.reduce((a, b) => a + b, 0) / toneValues.length;

      // Binning the tone values into 10 bins
      const minTone = Math.min(...toneValues);
      const maxTone = Math.max(...toneValues);
      const binSize = (maxTone - minTone) / 10;
      const toneBins = Array(10).fill(0);

      toneValues.forEach(value => {
        const binIndex = Math.min(Math.floor((value - minTone) / binSize), 9);
        toneBins[binIndex] += 1;
      });

      // Create labels for tone ranges
      const labels = Array.from({ length: 10 }, (_, i) => {
        const rangeStart = (minTone + i * binSize).toFixed(2);
        const rangeEnd = (minTone + (i + 1) * binSize).toFixed(2);
        return `${rangeStart} - ${rangeEnd}`;
      });

      return { toneBins, avgTone, labels };
    }

    function processThemesData(data) {
      if (!data) return { labels: [], counts: [], themes: {} };
      const rows = data.table.rows.slice(1); // Skip the header row
      const themes = {};
      rows.forEach(row => {
        const theme = row.c[1].v;
        const count = 0;
        const gkgID = row.c[0].v;
        if (themes[theme]) {
          themes[theme].count += 1;
          themes[theme].gkgIDs.push(gkgID);
        } else {
          themes[theme] = { count, gkgIDs: [gkgID] };
        }
      });
      const labels = Object.keys(themes).sort((a, b) => themes[b].count - themes[a].count).slice(0, 20);
      const counts = labels.map(label => themes[label].count);
      return { labels, counts, themes };
    }

    function processPersonsData(data) {
      if (!data) return { labels: [], counts: [], persons: {} };
      const rows = data.table.rows.slice(1); // Skip the header row
      const persons = {};
      rows.forEach(row => {
        const person = row.c[1].v;
        const count = 0;
        const gkgID = row.c[0].v;
        if (persons[person]) {
          persons[person].count += 1;
          persons[person].gkgIDs.push(gkgID);
        } else {
          persons[person] = { count, gkgIDs: [gkgID] };
        }
      });
      const labels = Object.keys(persons).sort((a, b) => persons[b].count - persons[a].count).slice(0, 20);
      const counts = labels.map(label => persons[label].count);
      return { labels, counts, persons };
    }

    function processOrgsData(data) {
      if (!data) return { labels: [], counts: [], orgs: {} };
      const rows = data.table.rows.slice(1); // Skip the header row
      const orgs = {};
      rows.forEach(row => {
        const org = row.c[1].v;
        const count = 0;
        const gkgID = row.c[0].v;
        if (orgs[org]) {
          orgs[org].count += 1;
          orgs[org].gkgIDs.push(gkgID);
        } else {
          orgs[org] = { count, gkgIDs: [gkgID] };
        }
      });
      const labels = Object.keys(orgs).sort((a, b) => orgs[b].count - orgs[a].count).slice(0, 20);
      const counts = labels.map(label => orgs[label].count);
      return { labels, counts, orgs };
    }

    function processDocsData(data) {
      if (!data) return [];
      const rows = data.table.rows.slice(1); // Skip the header row
      return rows.map(row => ({
        id: row.c[4].v,
        image: row.c[5].v,
        gkgID: row.c[0].v
      })).sort((a, b) => b.id.localeCompare(a.id)).slice(0, 10);
    }

    function processLocationsData(data) {
  if (!data || !data.table || !data.table.rows) return [];

  const rows = data.table.rows.slice(1); // Skip the header row
  const latlongMap = {};

  rows.forEach(row => {
    const lat = parseFloat(row.c[7]?.v);
    const lng = parseFloat(row.c[8]?.v);
    const gkgID = row.c[0]?.v;

    if (!isNaN(lat) && !isNaN(lng) && gkgID) {
      const key = `${lat},${lng}`; // Unique key for lat/lng combination

      if (!latlongMap[key]) {
        latlongMap[key] = { count: 0, gkgIDs: new Set() };
      }

      latlongMap[key].gkgIDs.add(gkgID); // Use a Set to store unique gkgIDs
      latlongMap[key].count = latlongMap[key].gkgIDs.size; // Count of unique gkgIDs
    }
  });

  // Convert latlongMap to an array of objects
  return Object.keys(latlongMap).map(key => {
    const [lat, lng] = key.split(',').map(Number);
    return {
      lat,
      lng,
      count: latlongMap[key].count,
      gkgIDs: Array.from(latlongMap[key].gkgIDs)
    };
  });
}


    function renderCharts(data) {
      // Tone Histogram
      const toneCtx = document.getElementById('toneHistogram').getContext('2d');
      const toneData = processToneData(data.tone);
      if (toneData.toneBins.length === 0) {
        document.getElementById('toneHistogram').style.display = 'none';
      } else {
        new Chart(toneCtx, {
        type: 'bar',
        data: {
          labels: toneData.labels, // Use the labels generated for the x-axis
          datasets: [{
            label: 'Tone Count',
            data: toneData.toneBins,
            backgroundColor: 'rgba(75, 192, 192, 0.2)',
            borderColor: 'rgba(75, 192, 192, 1)',
            borderWidth: 1
          }]
        },
        options: {
          scales: {
            x: {
              title: {
                display: true,
                text: 'Tone Range'
              },
              ticks: {
                callback: function(value, index, values) {
                  // Return the label for the tick on the x-axis
                  return toneData.labels[index];
                }
              }
            },
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Count'
              }
            }
          }
        }
      });
        document.getElementById('avgOverallTone').textContent = `Average Overall Tone: ${toneData.avgTone.toFixed(2)}`;
      }

      // Themes Chart
      const themeCtx = document.getElementById('themeBarChart').getContext('2d');
      const themesData = processThemesData(data.themes);
      new Chart(themeCtx, {
        type: 'bar',
        data: {
          labels: themesData.labels,
          datasets: [{
            label: 'Article Count',
            data: themesData.counts,
            backgroundColor: 'rgba(153, 102, 255, 0.2)',
            borderColor: 'rgba(153, 102, 255, 1)',
            borderWidth: 1
          }]
        },
        options: {
          indexAxis: 'y', // Make bars horizontal
          scales: {
            x: {
              beginAtZero: true
            }
          }
        }
      });

      // Persons Chart
      const personsCtx = document.getElementById('personsBarChart').getContext('2d');
      const personsData = processPersonsData(data.persons);
      new Chart(personsCtx, {
        type: 'bar',
        data: {
          labels: personsData.labels,
          datasets: [{
            label: 'Article Count',
            data: personsData.counts,
            backgroundColor: 'rgba(255, 159, 64, 0.2)',
            borderColor: 'rgba(255, 159, 64, 1)',
            borderWidth: 1
          }]
        },
        options: {
          indexAxis: 'y', // Make bars horizontal
          scales: {
            x: {
              beginAtZero: true
            }
          }
        }
      });

      // Organizations Chart
      const orgsCtx = document.getElementById('orgsBarChart').getContext('2d');
      const orgsData = processOrgsData(data.orgs);
      new Chart(orgsCtx, {
        type: 'bar',
        data: {
          labels: orgsData.labels,
          datasets: [{
            label: 'Article Count',
            data: orgsData.counts,
            backgroundColor: 'rgba(255, 99, 132, 0.2)',
            borderColor: 'rgba(255, 99, 132, 1)',
            borderWidth: 1
          }]
        },
        options: {
          indexAxis: 'y', // Make bars horizontal
          scales: {
            x: {
              beginAtZero: true
            }
          }
        }
      });

// Document Thumbnails
const docThumbnailsDiv = document.getElementById('docThumbnails');
const docsData = processDocsData(data.documents);

// Set to keep track of unique image URLs
const seenImages = new Set();

docsData.forEach(doc => {
  // Check if the image URL has already been processed
  if (seenImages.has(doc.image)) {
    return; // Skip if the image is a duplicate
  }

  // Add the image URL to the set of seen images
  seenImages.add(doc.image);

  const div = document.createElement('div');

  // Create the image element
  const img = document.createElement('img');
  img.src = doc.image;
  img.alt = 'Document Image';
  img.onerror = function() {
    // Remove the thumbnail div if the image fails to load
    div.remove();
  };

  // Create the link element
  const a = document.createElement('a');
  a.href = doc.id;
  a.target = '_blank';
  a.appendChild(img);

  div.appendChild(a);
  docThumbnailsDiv.appendChild(div);
});

      // Country Map with Bubbles
      const map = L.map('countryMap').setView([20, 0], 2);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
      }).addTo(map);
      const locationsData = processLocationsData(data.locations);
      locationsData.forEach(location => {
        L.circle([location.lat, location.lng], {
          color: 'blue',
          fillColor: '#30f',
          fillOpacity: 0.5,
          radius: location.count * 1000
        }).addTo(map);
      });
    }

    async function initialize() {
      const [toneData, themesData, documentsData, personsData, locationsData, orgsData] = await Promise.all([
        fetchSheetData(sheets.toneData),
        fetchSheetData(sheets.themesData),
        fetchSheetData(sheets.documentData),
        fetchSheetData(sheets.personsData),
        fetchSheetData(sheets.countryData),
        fetchSheetData(sheets.orgsData)
      ]);
      
      const data = {
        tone: toneData,
        themes: themesData,
        documents: documentsData,
        persons: personsData,
        locations: locationsData,
        orgs: orgsData
      };

      renderCharts(data);
    }

    initialize();
  </script>
</body>
</html>