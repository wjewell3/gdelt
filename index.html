<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GDELT News Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    #loadingBar {
      transition: width 0.4s ease;
    }
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    h1 {
      margin: 20px;
    }
    .chart-container {
      margin-bottom: 20px;
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #docThumbnails {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
    }
    #docThumbnails div {
      margin: 10px;
      text-align: center;
    }
    img {
      max-width: 250px;
      max-height: 250px;
      width: auto;
      height: auto;
    }
    .chart-container canvas {
      width: 100% !important;
      height: 100% !important;
    }
    .chart-row {
      display: flex;
      justify-content: space-between;
      width: 100%;
      height: 50vh;
    }
    .chart-row .chart-container {
      margin-right: 10px;
    }
    .chart-row .chart-container:last-child {
      margin-right: 0;
    }
    #countryMap {
      height: 100%;
      width: 100%;
    }
  </style>
</head>
<body>
  <h1>GDELT News Dashboard</h1>
  <div id="loadingBarContainer" style="position: fixed; top: 0; left: 0; width: 100%; height: 5px; background-color: #f3f3f3; z-index: 1000;">
    <div id="loadingBar" style="width: 0%; height: 100%; background-color: #4caf50;"></div>
  </div>
  <button id="resetButton" style="position: absolute; top: 10px; right: 10px; z-index: 1000;">Reset</button>

  <div class="chart-container">
    <h2>Articles</h2>
    <div id="docThumbnails"></div>
  </div>

  <div class="chart-row">
    <div class="chart-container">
      <h2>Tone Counts</h2>
      <canvas id="toneHistogram"></canvas>
      <div id="avgOverallTone"></div>
    </div>

    <div class="chart-container">
      <h2>Map Counts</h2>
      <div id="countryMap"></div>
    </div>
  </div>

  <div class="chart-row">
    <div class="chart-container">
      <h2>Person Counts</h2>
      <canvas id="personsBarChart"></canvas>
    </div>

    <div class="chart-container">
      <h2>Organization Counts</h2>
      <canvas id="orgsBarChart"></canvas>
    </div>
    
    <div class="chart-container">
      <h2>Theme Counts</h2>
      <canvas id="themeBarChart"></canvas>
    </div>
  </div>

</body>
</html>


  <script>
    let selections = {}; // when you click on a viz, this will store what was clicked and associated gkgIds
    let globalGkgIds = []; // Global variable to store selected GKG IDs
    let toneChart, themeChart, personsChart, orgsChart, mapChart; // chart instances
    let filteredData = {};
    let renderData = {};
    let selectedRenderData = {};
    const sheets = {
      toneData: 'https://docs.google.com/spreadsheets/d/1Ct9OJZXJFgPXS0A1_TAstrHR4AIxyhegQDH0-gODP9k/edit?usp=drive_link/edit?gid=0#gid=0',
      themesData: 'https://docs.google.com/spreadsheets/d/12OWbeM-QywGaHxAs3xVSIkmdQOKLva2nFLxkLrMeaTg/edit?usp=drive_link/edit?gid=0#gid=0',
      documentData: 'https://docs.google.com/spreadsheets/d/1Ct9OJZXJFgPXS0A1_TAstrHR4AIxyhegQDH0-gODP9k/edit?usp=drive_link/edit?gid=0#gid=0',
      personsData: 'https://docs.google.com/spreadsheets/d/1btPN5QimxjvrYdy1DvcaoKtN2uwuSHkZFjlq6yoU5gU/edit?usp=drive_link/edit?gid=0#gid=0',
      countryData: 'https://docs.google.com/spreadsheets/d/13KdBTY_aS-T_1T6_bAhTHxKwur18yCaUDUypqZfgHc4/edit?usp=drive_link/edit?gid=0#gid=0',
      orgsData: 'https://docs.google.com/spreadsheets/d/1My2Q6pZ9xKyuJM_k1vrnXYX1ma9un4ecutUbEwfKrOI/edit?usp=drive_link/edit?gid=0#gid=0'
    };

    const dataUrl = 'https://us-central1-gdelt-433201.cloudfunctions.net/function-3';
    let pollingAttempts = 0;
    const maxPollingAttempts = 1;

    async function fetchData() {
      try {
        // Use 'no-cors' mode since you don't care about the response
        await fetch(dataUrl, { mode: 'no-cors' });
        console.log('Request made to:', dataUrl);
      } catch (error) {
        console.error('Failed to make request:', error);
      }
    }

    async function checkForUpdates() {
      await fetchData();

      if (pollingAttempts < maxPollingAttempts) {
        pollingAttempts++;
        setTimeout(checkForUpdates, 30000); // Poll every 30 seconds
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      checkForUpdates();
    });

    async function fetchSheetData(sheetUrl) {
      try {
        const sheetId = sheetUrl.split('/')[5];
        const sheetName = sheetUrl.split('gid=')[1];
        const url = `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:json&sheet=${sheetName}`;
        const response = await fetch(url);
        const text = await response.text();
        const match = text.match(/\{.*\}/s);
        if (match) {
          return JSON.parse(match[0]);
        }
        throw new Error('Failed to parse JSON data');
      } catch (error) {
        console.error('Failed to fetch or parse data:', error);
        return null;
      }
    }

    function processToneData(data) {
      // console.log("Tone Data:", data); // Debugging line
      // console.log(data)
      if (!data) return { toneBins: [], avgTone: 0, labels: [] };
      const rows = data.table.rows.slice(1); // Skip the header row
      const toneValues = rows.map(row => parseFloat(row.c[7].v)); // Adjust index if needed
      const avgTone = toneValues.reduce((a, b) => a + b, 0) / toneValues.length;

      // Binning the tone values into 10 bins
      const minTone = Math.min(...toneValues);
      const maxTone = Math.max(...toneValues);
      const binSize = (maxTone - minTone) / 10;
      const toneBins = Array(10).fill(0);
// come back and fill this in to get associated gkg ids like we did for themes
      // rows.forEach(row => {
      //   const tone = row.c[7].v;
      //   const count = 0;
      //   const gkgID = row.c[0].v;
      //   if (themes[theme]) {
      //     themes[theme].count += 1;
      //     themes[theme].gkgIDs.push(gkgID);
      //   } else {
      //     themes[theme] = { count, gkgIDs: [gkgID] };
      //   }
      // });

      toneValues.forEach(value => {
        const binIndex = Math.min(Math.floor((value - minTone) / binSize), 9);
        toneBins[binIndex] += 1;
      });

      // Create labels for tone ranges
      const labels = Array.from({ length: 10 }, (_, i) => {
        const rangeStart = (minTone + i * binSize).toFixed(2);
        const rangeEnd = (minTone + (i + 1) * binSize).toFixed(2);
        return `${rangeStart} - ${rangeEnd}`;
      });

      return { toneBins, avgTone, labels };
    }

    function processThemesData(data) {
      if (!data) return { labels: [], counts: [], themes: {} };
      const rows = data.table.rows.slice(1); // Skip the header row
      const themes = {};
      rows.forEach(row => {
        const theme = row.c[1].v;
        const count = 0;
        const gkgID = row.c[0].v;
        if (themes[theme]) {
          themes[theme].count += 1;
          themes[theme].gkgIDs.push(gkgID);
        } else {
          themes[theme] = { count, gkgIDs: [gkgID] };
        }
      });
      const labels = Object.keys(themes).sort((a, b) => themes[b].count - themes[a].count);
      const counts = labels.map(label => themes[label].count);
      // console.log(themes)
      return { labels, counts, themes };
    }

    function processPersonsData(data) {
      if (!data) return { labels: [], counts: [], persons: {} };
      const rows = data.table.rows.slice(1); // Skip the header row
      const persons = {};
      rows.forEach(row => {
        const person = row.c[1].v;
        const count = 0;
        const gkgID = row.c[0].v;
        if (persons[person]) {
          persons[person].count += 1;
          persons[person].gkgIDs.push(gkgID);
        } else {
          persons[person] = { count, gkgIDs: [gkgID] };
        }
      });
      const labels = Object.keys(persons).sort((a, b) => persons[b].count - persons[a].count);
      const counts = labels.map(label => persons[label].count);
      return { labels, counts, persons };
    }

    function processOrgsData(data) {
      if (!data) return { labels: [], counts: [], orgs: {} };
      const rows = data.table.rows.slice(1); // Skip the header row
      const orgs = {};
      rows.forEach(row => {
        const org = row.c[1].v;
        const count = 0;
        const gkgID = row.c[0].v;
        if (orgs[org]) {
          orgs[org].count += 1;
          orgs[org].gkgIDs.push(gkgID);
        } else {
          orgs[org] = { count, gkgIDs: [gkgID] };
        }
      });
      const labels = Object.keys(orgs).sort((a, b) => orgs[b].count - orgs[a].count);
      const counts = labels.map(label => orgs[label].count);
      return { labels, counts, orgs };
    }

    function processDocsData(data) {
      if (!data) return [];
      const rows = data.table.rows.slice(1); // Skip the header row
      return rows.map(row => ({
        id: row.c[4].v,
        image: row.c[5].v,
        gkgID: row.c[0].v
      })).sort((a, b) => b.id.localeCompare(a.id));
    }

    function processLocationsData(data) {
      if (!data || !data.table || !data.table.rows) return [];

      const rows = data.table.rows.slice(1); // Skip the header row
      const latlongMap = {};

      rows.forEach(row => {
        const lat = parseFloat(row.c[7]?.v);
        const lng = parseFloat(row.c[8]?.v);
        const gkgID = row.c[0]?.v;

        if (!isNaN(lat) && !isNaN(lng) && gkgID) {
          const key = `${lat},${lng}`; // Unique key for lat/lng combination

          if (!latlongMap[key]) {
            latlongMap[key] = { count: 0, gkgIDs: new Set() };
          }

          latlongMap[key].gkgIDs.add(gkgID); // Use a Set to store unique gkgIDs
          latlongMap[key].count = latlongMap[key].gkgIDs.size; // Count of unique gkgIDs
        }
      });

      // Convert latlongMap to an array of objects
      return Object.keys(latlongMap).map(key => {
        const [lat, lng] = key.split(',').map(Number);
        return {
          lat,
          lng,
          count: latlongMap[key].count,
          gkgIDs: Array.from(latlongMap[key].gkgIDs)
        };
      });
    }

    function filterDataByGkgIds(gkgIds) {
      // Helper function to filter rows based on GKG IDs
      function filterRowsByGkgIds(renderData) {
        if (!renderData || !renderData.table || !renderData.table.rows) return renderData;
        return {
          ...renderData,
          table: {
            ...renderData.table,
            rows: renderData.table.rows.filter(row => gkgIds.includes(row.c[0].v))
          }
        };
      };
      // Process each dataset using the helper function
      filteredData = {
        tone: processToneData(filterRowsByGkgIds(initialSheetData.tone)),
        themes: processThemesData(filterRowsByGkgIds(initialSheetData.themes)),
        documents: processDocsData(filterRowsByGkgIds(initialSheetData.documents)),
        persons: processPersonsData(filterRowsByGkgIds(initialSheetData.persons)),
        locations: processLocationsData(filterRowsByGkgIds(initialSheetData.locations)),
        orgs: processOrgsData(filterRowsByGkgIds(initialSheetData.orgs))
      };
      // console.log(toneData.table)
      return filteredData;
    }


function handleChartClick(event, elements, chartData, chartType) {
  console.log('HandleChartClick...')
  console.log('Event:', event);
  console.log('Elements:', elements);
  console.log('Chart Data:', chartData);

  if (elements.length > 0) {
    const index = elements[0].index;
    const Label = event.chart.data.labels[index];
    if (chartData[Label]) {
      console.log("Label: ",Label);
      if (selections[Label]) {
        console.log("deleting selections label", selections[Label]);
        delete selections[Label];
      } else {
        console.log("assigning selections label", Label);
      selections[Label] = chartData[Label].gkgIDs;
      console.log("selections", selections);
      }

      globalGkgIds = Array.from(new Set(Object.values(selections).flat()));
      console.log("globalGkgIds:",globalGkgIds)
      if (globalGkgIds.length > 0) selectedRenderData = filterDataByGkgIds(globalGkgIds);
      renderCharts();
    } else {
      console.error(`No data found for label: ${Label}`);
    }

}
}


    function renderCharts() {
      if (toneChart) toneChart.destroy();
      if (themeChart) themeChart.destroy();
      if (personsChart) personsChart.destroy();
      if (orgsChart) orgsChart.destroy();
        // Check if the map already exists, and if so, remove it
      if (mapChart) {
        mapChart.remove();
        mapChart = null;
      }
      if (Object.keys(selections).length === 0) { // if selections is empty, load initial data
        renderData = initialRenderData;
        console.log("loading initial data", renderData);
      } else {
        renderData = selectedRenderData;
        console.log("loading selected data", renderData);
      }
      const toneCtx = document.getElementById('toneHistogram').getContext('2d');
      // const toneData = processToneData(data.tone);
      if (renderData.tone.toneBins.length === 0) {
        document.getElementById('toneHistogram').style.display = 'none';
      } else {
        toneChart = new Chart(toneCtx, {
          type: 'bar',
          data: {
            labels: renderData.tone.labels,
            datasets: [{
              label: 'Tone Count',
              data: renderData.tone.toneBins,
              backgroundColor: 'rgba(75, 192, 192, 0.2)',
              borderColor: 'rgba(75, 192, 192, 1)',
              borderWidth: 1
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false, // Allow the chart to fill its container
            scales: {
              x: {
                title: {
                  display: true,
                  text: 'Tone Range'
                },
                ticks: {
                  callback: function(value, index) {
                    return renderData.tone.labels[index];
                  }
                }
              },
              y: {
                beginAtZero: true,
                title: {
                  display: true,
                  text: 'Count'
                }
              }
            },
            // onClick: (event, elements) => handleChartClick(event, elements, data.tone.toneBins, 'tone')

          }
        });
        document.getElementById('avgOverallTone').textContent = `Average Overall Tone: ${renderData.tone.avgTone.toFixed(2)}`;
      }

  const themeCtx = document.getElementById('themeBarChart').getContext('2d');
  // const themesData = processThemesData(data.themes);
  // console.log('data.themes.themes: ',data.themes.themes)
  themeChart = new Chart(themeCtx, {
    type: 'bar',
    data: {
      labels: renderData.themes.labels.slice(0,9),
      datasets: [{
        label: 'Article Count',
        data: renderData.themes.counts.slice(0,9),
        backgroundColor: 'rgba(153, 102, 255, 0.2)',
        borderColor: 'rgba(153, 102, 255, 1)',
        borderWidth: 1
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false, // Allow the chart to fill its container
      indexAxis: 'y',
      scales: {
        x: {
          beginAtZero: true
        }
      },
      onClick: (event, elements) => handleChartClick(event, elements, renderData.themes.themes, 'themes')
    }
  });

  const personsCtx = document.getElementById('personsBarChart').getContext('2d');
  // const personsData = processPersonsData(data.persons);
  personsChart = new Chart(personsCtx, {
    type: 'bar',
    data: {
      labels: renderData.persons.labels.slice(0,9),
      datasets: [{
        label: 'Article Count',
        data: renderData.persons.counts.slice(0,9),
        backgroundColor: 'rgba(255, 159, 64, 0.2)',
        borderColor: 'rgba(255, 159, 64, 1)',
        borderWidth: 1
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false, // Allow the chart to fill its container
      indexAxis: 'y',
      scales: {
        x: {
          beginAtZero: true
        }
      },
      onClick: (event, elements) => handleChartClick(event, elements, renderData.persons.persons, 'persons')
    }
  });

  const orgsCtx = document.getElementById('orgsBarChart').getContext('2d');
  // const orgsData = processOrgsData(data.orgs);
  orgsChart = new Chart(orgsCtx, {
    type: 'bar',
    data: {
      labels: renderData.orgs.labels.slice(0,9),
      datasets: [{
        label: 'Article Count',
        data: renderData.orgs.counts.slice(0,9),
        backgroundColor: 'rgba(255, 99, 132, 0.2)',
        borderColor: 'rgba(255, 99, 132, 1)',
        borderWidth: 1
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false, // Allow the chart to fill its container
      indexAxis: 'y',
      scales: {
        x: {
          beginAtZero: true
        }
      },
      onClick: (event, elements) => handleChartClick(event, elements, renderData.orgs.orgs, 'orgs')
    }
  });

  const docThumbnailsDiv = document.getElementById('docThumbnails');
  docThumbnailsDiv.innerHTML = ''; // Clear previous thumbnails

  // Shuffle the array of documents to get a random selection
  const shuffledDocuments = renderData.documents.sort(() => 0.5 - Math.random());

  // Take the first 10 documents from the shuffled array
  const selectedDocuments = shuffledDocuments.slice(0, 10);

  const seenImages = new Set();

  selectedDocuments.forEach(doc => {
    if (seenImages.has(doc.image)) {
      return;
  }

  seenImages.add(doc.image);

  const div = document.createElement('div');

  const img = document.createElement('img');
  img.src = doc.image;
  img.alt = 'Document Image';
  img.onerror = function() {
    div.remove();
  };

  const a = document.createElement('a');
  a.href = doc.id;
  a.target = '_blank';
  a.appendChild(img);

  div.appendChild(a);
  docThumbnailsDiv.appendChild(div);
});


  // Initialize the map only if it's not already initialized
  if (!mapChart) {
    mapChart = L.map('countryMap').setView([20, 0], 2);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(mapChart);
  }

  // const locationsData = processLocationsData(data.locations);
  renderData.locations.forEach(location => {
    L.circle([location.lat, location.lng], {
      color: 'blue',
      fillColor: '#30f',
      fillOpacity: 0.5,
      radius: location.count * 1000
    }).addTo(mapChart);
  });
}

async function initialize() {
  // Show loading bar
  const loadingBar = document.getElementById('loadingBar');
  loadingBar.style.width = '0%'; // Reset the loading bar

  try {
    // Start loading data
    loadingBar.style.width = '20%';
    const toneData = await fetchSheetData(sheets.toneData);
    loadingBar.style.width = '40%';
    const themesData = await fetchSheetData(sheets.themesData);
    loadingBar.style.width = '60%';
    const documentsData = await fetchSheetData(sheets.documentData);
    loadingBar.style.width = '80%';
    const personsData = await fetchSheetData(sheets.personsData);
    loadingBar.style.width = '90%';
    const locationsData = await fetchSheetData(sheets.countryData);
    loadingBar.style.width = '95%';
    const orgsData = await fetchSheetData(sheets.orgsData);

    initialSheetData = {
      tone: toneData, 
      themes: themesData, 
      documents: documentsData, 
      persons: personsData, 
      locations: locationsData, 
      orgs: orgsData
    };

    initialRenderData = {
      tone: processToneData(initialSheetData.tone),
      themes: processThemesData(initialSheetData.themes),
      documents: processDocsData(initialSheetData.documents),
      persons: processPersonsData(initialSheetData.persons),
      locations: processLocationsData(initialSheetData.locations),
      orgs: processOrgsData(initialSheetData.orgs)
    };
    // Render charts with the processed data
    renderCharts();

    // Hide loading bar
    loadingBar.style.width = '100%';
    setTimeout(() => {
      document.getElementById('loadingBarContainer').style.display = 'none';
    }, 500); // Allow a small delay for the full bar to be visible

  } catch (error) {
    console.error('Error fetching data:', error);
    // Hide loading bar if there's an error
    document.getElementById('loadingBarContainer').style.display = 'none';
  }
}

initialize();

document.getElementById('resetButton').addEventListener('click', async function() {
  // Call the initialize function when the reset button is clicked
  selectedRenderData = {};
  await renderCharts();
});

  </script>
</body>
</html>